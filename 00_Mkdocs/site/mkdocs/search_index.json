{
    "docs": [
        {
            "location": "/",
            "text": "Welcome!\n\n\nHello!\nMy name is Adam Frewen, I am a game developer in training!\nWelcome to my game programming portfolio.\nThe following contents consist largely of learnings gained through one semester taking a university Game Programming paper.\nUpon graduating at the end of 2016 I aspire to build on these skills through working on projects in my free time and taking part in community game jams!\n\n\nContents\n\n\n\n\n\n\nUniversity Projects\n\n\n\n\nSmash n' Dash\n\n\nThe Second to Last of Us\n\n\n\n\n\n\n\n\nSelf Learning\n\n\n\n\nLevel Manager\n\n\nFMOD\n\n\nBox2D\n\n\n\n\n\n\n\n\nPast Projects\n\n\n\n\nRoost Riders\n\n\nGopher Launch\n\n\n\n\n\n\n\n\nResume\n\n\n\n\nResume\n\n\nContact details\n\n\nReferences",
            "title": "Home"
        },
        {
            "location": "/#welcome",
            "text": "Hello!\nMy name is Adam Frewen, I am a game developer in training!\nWelcome to my game programming portfolio.\nThe following contents consist largely of learnings gained through one semester taking a university Game Programming paper.\nUpon graduating at the end of 2016 I aspire to build on these skills through working on projects in my free time and taking part in community game jams!",
            "title": "Welcome!"
        },
        {
            "location": "/#contents",
            "text": "University Projects   Smash n' Dash  The Second to Last of Us     Self Learning   Level Manager  FMOD  Box2D     Past Projects   Roost Riders  Gopher Launch     Resume   Resume  Contact details  References",
            "title": "Contents"
        },
        {
            "location": "/universityprojects/",
            "text": "University Projects\n\n\nWhile at the Auckland University of Technology I took part in the Game Programming paper.\nThis paper presented me with the opportunity to learn coding in C++ and learn the fundamentals of game programming from an industry professional.\nThese two games are examples of my first venture into game programming and C++ in general.\nTaking part in the Game Programming paper was a great opportunity through which I learnt a lot. I look forward to improving upon the skills I have gained to date.\nA basic framework was provided to students to act as a starting code platform for these projects. The framework only provided a basic structure with many missing code sections for students to fill in while building their games.\nThis framework is hosted by AUT and therefor only accessible by students (AUT, n.d.).\n\n\nIndividual Game Project\n\n\nSmash n' Dash\n\n\nSmash n' Dash was an individual project where I first got to stretch my legs with coding a full game in C++ from conception to gold build.\nI learnt a lot. My key lesson here being the importance of tracking memory leaks from the start. I impleneted Visual Leak Detector later in the project but was unable to resolve all of my leaks before the deadline.\nBox2D was also used for the first time. I later found that I had made an error in the placement of my Box2D bodies. Box2D uses positioning off of a central point, whereas our SDL sprites and the like anchor to the top left.\nThis had no impact on my game as all sprites were the same size and therefore offset with their physics body by the same margin.\n\n\nLinks\n\n\n\n\nDownload - Smash n' Dash\n\n\nGithub Source Code - Smash n' Dash\n\n\nGDD - Smash n' Dash\n\n\nTDD - Smash n' Dash\n\n\n\n\n\n\nTeam Game Project\n\n\nThe Second to Last of Us\n\n\nThe Second to Last of Us allowed me to improve upon what I had learnt during production of Smash n' Dash. I'm proud to say that memory leaks have been kept at a solid 0! While they pop up from time to time when something new is implemented. They are always dealt with immediately.\nBox2D position was also factored in correctly. Game assets are of different sizes and not always a magic number. Therefore they would have been noticably broken if implemented in the incorrect manner that was used in Smash n' Dash.\nOne of the larger challenges faced during production was the implementation of a scrollable level. This was resolved by creating a \"playable\" bounds region on the center of the screen that player movement was limited too.\nIf the player's movement had them leave the region of this playable bounds, the player position would instead be reset back slightly within bounds and level and all of the assets within it would be moved instead.\nI am still uncertain about the efficiency of this method and given the opportunity I would like to revisit the method to see what improvements could be made. Moving the renderable region of the screen as you would a camera would be preferable.\n\n\nLinks\n\n\n\n\nDownload - The Second to Last of US\n (Frewen, Hoon Jho, & Pike, n.d.)\n\n\nGithub Source Code - The Second to Last of Us\n (Frewen, Hoon Jho, & Pike, n.d.)\n\n\nGDD - The Second to Last of Us\n (Frewen, Hoon Jho, & Pike, n.d.)\n\n\nTDD - The Second to Last of Us\n (Frewen, Hoon Jho, & Pike, n.d.)\n\n\n\n\n\n\nReferences\n\n\n\n\n\n\nAUT. (n.d.). GP2DFramework. Retrieved October 22, 2016, from \nhttps://blackboard.aut.ac.nz/bbcswebdav/pid-3865534-dt-content-rid-7060285_4/xid-7060285_4\n\n\n\n\n\n\nFrewen, A., Hoon Jho, S., & Pike, A. (n.d.). The Second to Last of Us. Retrieved from \nhttps://github.com/Kolosso/The-Second-to-Last-of-Us",
            "title": "University Projects"
        },
        {
            "location": "/universityprojects/#university-projects",
            "text": "While at the Auckland University of Technology I took part in the Game Programming paper.\nThis paper presented me with the opportunity to learn coding in C++ and learn the fundamentals of game programming from an industry professional.\nThese two games are examples of my first venture into game programming and C++ in general.\nTaking part in the Game Programming paper was a great opportunity through which I learnt a lot. I look forward to improving upon the skills I have gained to date.\nA basic framework was provided to students to act as a starting code platform for these projects. The framework only provided a basic structure with many missing code sections for students to fill in while building their games.\nThis framework is hosted by AUT and therefor only accessible by students (AUT, n.d.).",
            "title": "University Projects"
        },
        {
            "location": "/universityprojects/#individual-game-project",
            "text": "",
            "title": "Individual Game Project"
        },
        {
            "location": "/universityprojects/#smash-n-dash",
            "text": "Smash n' Dash was an individual project where I first got to stretch my legs with coding a full game in C++ from conception to gold build.\nI learnt a lot. My key lesson here being the importance of tracking memory leaks from the start. I impleneted Visual Leak Detector later in the project but was unable to resolve all of my leaks before the deadline.\nBox2D was also used for the first time. I later found that I had made an error in the placement of my Box2D bodies. Box2D uses positioning off of a central point, whereas our SDL sprites and the like anchor to the top left.\nThis had no impact on my game as all sprites were the same size and therefore offset with their physics body by the same margin.",
            "title": "Smash n' Dash"
        },
        {
            "location": "/universityprojects/#links",
            "text": "Download - Smash n' Dash  Github Source Code - Smash n' Dash  GDD - Smash n' Dash  TDD - Smash n' Dash",
            "title": "Links"
        },
        {
            "location": "/universityprojects/#team-game-project",
            "text": "",
            "title": "Team Game Project"
        },
        {
            "location": "/universityprojects/#the-second-to-last-of-us",
            "text": "The Second to Last of Us allowed me to improve upon what I had learnt during production of Smash n' Dash. I'm proud to say that memory leaks have been kept at a solid 0! While they pop up from time to time when something new is implemented. They are always dealt with immediately.\nBox2D position was also factored in correctly. Game assets are of different sizes and not always a magic number. Therefore they would have been noticably broken if implemented in the incorrect manner that was used in Smash n' Dash.\nOne of the larger challenges faced during production was the implementation of a scrollable level. This was resolved by creating a \"playable\" bounds region on the center of the screen that player movement was limited too.\nIf the player's movement had them leave the region of this playable bounds, the player position would instead be reset back slightly within bounds and level and all of the assets within it would be moved instead.\nI am still uncertain about the efficiency of this method and given the opportunity I would like to revisit the method to see what improvements could be made. Moving the renderable region of the screen as you would a camera would be preferable.",
            "title": "The Second to Last of Us"
        },
        {
            "location": "/universityprojects/#links_1",
            "text": "Download - The Second to Last of US  (Frewen, Hoon Jho, & Pike, n.d.)  Github Source Code - The Second to Last of Us  (Frewen, Hoon Jho, & Pike, n.d.)  GDD - The Second to Last of Us  (Frewen, Hoon Jho, & Pike, n.d.)  TDD - The Second to Last of Us  (Frewen, Hoon Jho, & Pike, n.d.)",
            "title": "Links"
        },
        {
            "location": "/universityprojects/#references",
            "text": "AUT. (n.d.). GP2DFramework. Retrieved October 22, 2016, from  https://blackboard.aut.ac.nz/bbcswebdav/pid-3865534-dt-content-rid-7060285_4/xid-7060285_4    Frewen, A., Hoon Jho, S., & Pike, A. (n.d.). The Second to Last of Us. Retrieved from  https://github.com/Kolosso/The-Second-to-Last-of-Us",
            "title": "References"
        },
        {
            "location": "/selflearning/",
            "text": "Self Learning\n\n\nGeneral\n\n\nLevel Manager\n\n\nThe Level Manager is a class I put together to help build grid based levels quickly and easily so they can be implemented rapidly for in game testing.\nA text document holds the data to be read in by the game. Working with Excel a document, a level is created by entering single characters into cells that represent different tile types that the Level Manager will create.\nThe Excel documents visual layout assists with giving a representation for the level layout early on.\n\n\nLevel Manager : Excel Document\n\n\n\n\nLevel Manager : Code\n\n\n// This includes:\n#include \"LevelManager.h\"\n\n// Local includes:\n#include \"BackBuffer.h\"\n#include \"Sprite.h\"\n#include \"Tile.h\"\n#include <string>\n\n// Library includes:\n\nLevelManager::LevelManager()\n: mi_levelWidth(0)\n, mi_levelHeight(0)\n{\n\n}\n\nLevelManager::~LevelManager()\n{\n    // delete tiles\n    for (unsigned int i = 0; i < tiles.size(); ++i)\n    {\n        //tiles[i]->~Tile();\n        delete tiles[i];\n        tiles[i] = 0;\n    }\n    tiles.clear();\n    //std::vector<Tile*>().swap(tiles);\n}\n\nbool\nLevelManager::Initialise()\n{\n    ReadFile();\n\n    return (true);\n}\n\nvoid\nLevelManager::Process(float deltaTime)\n{\n    for (unsigned int i = 0; i < tiles.size(); ++i)\n    {\n        tiles[i]->Process(deltaTime);\n    }\n}\n\nvoid\nLevelManager::Draw(BackBuffer& backBuffer)\n{\n    for (unsigned int i = 0; i < tiles.size(); ++i)\n    {\n        tiles[i]->Draw(backBuffer);\n    }\n}\n\nvoid\nLevelManager::ReadFile()\n{\n    mapFile.open(\"assets\\\\Level\\\\maplayout.txt\");\n}\n\nvoid\nLevelManager::CreateLevel(BackBuffer* mp_backBuffer, b2World* gameWorld)\n{\n    char tileID;\n\n    // Find Width and Height specified in file. Convert to int.\n    std::string strWidth;\n    std::getline(mapFile, strWidth);\n    std::string strHeight;\n    std::getline(mapFile, strHeight);\n    int mi_levelWidth = atoi(strWidth.c_str());\n    int mi_levelHeight = atoi(strHeight.c_str());\n\n    // Iterate through .txt file and setup tiles.\n    for (int posH = 0; posH < mi_levelHeight; ++posH)\n    {\n        for (int posW = 0; posW < mi_levelWidth; ++posW)\n        {\n            Sprite* pTileSprite;\n\n            mapFile >> (tileID);\n\n            switch (tileID)\n            {\n            case GROUND:\n                //pTileSprite = mp_backBuffer->CreateSprite(\"assets\\\\ground.png\");\n                pTileSprite = mp_backBuffer->CreateSprite(\"assets\\\\Level\\\\ground.png\");\n\n                SetupCollisionTile(pTileSprite, posW, posH, gameWorld, false);\n                break;\n            case WALL:\n                //pTileSprite = mp_backBuffer->CreateSprite(\"assets\\\\wall.png\");\n                pTileSprite = mp_backBuffer->CreateSprite(\"assets\\\\Level\\\\wall.png\");\n\n                SetupCollisionTile(pTileSprite, posW, posH, gameWorld, true);\n                break;\n            case BUILDING:\n                pTileSprite = mp_backBuffer->CreateSprite(\"assets\\\\Level\\\\building.png\");\n\n                SetupCollisionTile(pTileSprite, posW, posH, gameWorld, true);\n                break;\n            default:\n                // Used to catch cases where the tileID does not match. Will draw placeholder asset.\n                pTileSprite = mp_backBuffer->CreateSprite(\"assets\\\\Level\\\\placeholder.png\");\n\n                SetupTile(pTileSprite, posW, posH);\n                break;\n            }\n        }\n    }\n}\n\n// Creates a Tile WITHOUT Box2D properties\nvoid \nLevelManager::SetupTile(Sprite* sprite, int posW, int posH)\n{\n    // Get Sprite width / height\n    int sW = sprite->GetWidth();\n    int sH = sprite->GetWidth();\n\n    Tile* tile = new Tile();\n\n    tile->SetPos(b2Vec2((float)posW * sW, (float)posH * sH));\n    tile->Initialise(sprite); // Height and Width taken as half lengths object width = 2*given width\n\n    tiles.push_back(tile);\n}\n\n// Creates a tile WITH Box2D properties\nvoid\nLevelManager::SetupCollisionTile(Sprite* sprite, int posW, int posH, b2World* gameWorld, bool collision)\n{\n    // Get Sprite width / height\n    int sW = sprite->GetWidth();\n    int sH = sprite->GetWidth();\n\n    Tile* tile = new Tile();\n\n    tile->SetPos(b2Vec2((float)posW * sW, (float)posH * sH));\n    tile->Initialise(sprite, gameWorld, collision); \n\n    tiles.push_back(tile);\n}\n\nvoid\nLevelManager::LevelMoveTiles(float x, float y)\n{\n    for (unsigned int i = 0; i < tiles.size(); ++i)\n    {\n        if (tiles[i]->GetBox2DBody() != 0)\n        {\n            tiles[i]->Move(x, y);\n        }\n        else\n        {\n            //tiles[i]->SetPositionX(x);\n            //tiles[i]->SetPositionY(y);\n        }\n    }\n}\n\nvoid\nLevelManager::LevelStopTiles()\n{\n    for (unsigned int i = 0; i < tiles.size(); ++i)\n    {\n        if (tiles[i]->GetBox2DBody() != 0)\n        {\n            tiles[i]->GetBox2DBody()->SetLinearVelocity(b2Vec2(0, 0));\n        }\n        else\n        {\n\n        }\n    }\n}\n\nstd::vector<Tile*>\nLevelManager::GetTiles()\n{\n    return tiles;\n}\n\n\n\n\nThird Party\n\n\nBox2D\n\n\nI picked up Box2D during my game project assignments I took part in while at university.\nBox2D has very well written documentation with numerous other experienced users available online sharing their troubles and solutions.\nThe only issues I faced when using Box2D where the usual growing pains experienced when getting use to something new.\nWhile working with Box2D and SDL. Box2D's positional values had to be adjusted to fit in the scale of the SDL environment.\nThe below example was used to create the Box2D bodies for the level tiles created by the Level Manager.\nOnly walls required full collision information. Whereas the floor tiles only needed a based body to handle positioning.\n\n\nBox2D : Code\n\n\nvoid\nTile::box2DBodyCreate(b2World* gameWorld, bool collision, float mf_spriteWidth, float mf_spriteHeight)\n{\n    b2BodyDef m_entityBodyDef;\n    m_entityBodyDef.type = b2_kinematicBody;\n    // Origin is at center. Must be offset by sprite width/height\n    // Position settings adjusted based on scale differences between SDL and Box2D\n    m_entityBodyDef.position.Set((mv_pos.x + mf_spriteWidth) * mf_worldScaleB2D, (mv_pos.y + mf_spriteHeight) * mf_worldScaleB2D);\n    m_entityBodyDef.angle = 0;\n    m_entityBodyDef.allowSleep = true;\n    m_entityBodyDef.gravityScale = 0.0f;\n\n    mp_body = gameWorld->CreateBody(&m_entityBodyDef);\n    mp_body->SetUserData(this);\n\n    // Create collision shape if object should collide\n    if (collision)\n    {\n        b2PolygonShape boxShape;\n        // Creates width and height of box (half measures used), given the center, angle\n        boxShape.SetAsBox(mf_spriteWidth * mf_worldScaleB2D, mf_spriteHeight * mf_worldScaleB2D);\n\n        b2FixtureDef boxFixtureDef;\n        boxFixtureDef.shape = &boxShape;\n        boxFixtureDef.friction = 100;\n        boxFixtureDef.filter.categoryBits = 0x0001;\n        boxFixtureDef.filter.maskBits = 0x0001 | 0x0002 | 0x0003 | 0x0004;\n\n        mp_body->CreateFixture(&boxFixtureDef);\n    }\n}\n\n\n\n\n(Box2D, n.d.)\n\n\nFMOD\n\n\nAn Audio Manager class was created to handle my game sounds while working on my university projects.\nOnce again, the documentation for FMOD was very well written and easy to implement. I found it best to setup FMOD within an Audio Manager class.\nThis gave me greater control over the use of sound effects within my games. I also put together little volume controls and channels to allow me to control the volume of my music VS sound effects at different ratios.\n\n\nAudio Manager : Code\n\n\n// Local includes:\n#include \"AudioManager.h\"\n\n// Library includes:\n#include <iostream>\n\nAudioManager::AudioManager()\n: mp_FMODsystem(0)\n, mp_FMODchannel(0)\n, mp_FMODchannelMusic(0)\n, mp_FMODsound_music(nullptr)\n, mp_FMODsound_pShoot(0)\n, mp_FMODsound_pReload(0)\n, mp_FMODsound_pPickup(0)\n, mp_FMODsound_pDeath(0)\n, mp_FMODsound_zGroan1(0)\n, mp_FMODsound_zGroan2(0)\n, mp_FMODsound_zAttack(0)\n, mp_FMODsound_zDeath(0)\n, volume(0.7f)\n, volumeMusic(volume / 3)\n, muted(false)\n{\n}\n\nAudioManager::~AudioManager()\n{\n    mp_FMODsystem->release();\n}\n\nbool\nAudioManager::Initialise()\n{\n    FMOD_RESULT result;\n\n    result = FMOD::System_Create(&mp_FMODsystem);      // Create the main system object.\n    if (result != FMOD_OK)\n    {\n        printf(\"FMOD error! (%d) %s\\n\", result, FMOD_ErrorString(result));\n        exit(-1);\n    }\n\n    result = mp_FMODsystem->init(512, FMOD_INIT_NORMAL, 0);    // Initialize FMOD.\n    if (result != FMOD_OK)\n    {\n        printf(\"FMOD error! (%d) %s\\n\", result, FMOD_ErrorString(result));\n        exit(-1);\n    }\n    // Player Sound Effects\n    result = mp_FMODsystem->createSound(\"assets\\\\soundFX\\\\SOUNDEFFECT.wav\", FMOD_2D, 0, &mp_FMODsound_pShoot);\n    result = mp_FMODsystem->createSound(\"assets\\\\soundFX\\\\SOUNDEFFECT.wav\", FMOD_2D, 0, &mp_FMODsound_pReload);\n    result = mp_FMODsystem->createSound(\"assets\\\\soundFX\\\\SOUNDEFFECT.wav\", FMOD_2D, 0, &mp_FMODsound_pPickup);\n    result = mp_FMODsystem->createSound(\"assets\\\\soundFX\\\\SOUNDEFFECT.wav\", FMOD_2D, 0, &mp_FMODsound_pDeath);\n    // Zombie Sound Effects\n    result = mp_FMODsystem->createSound(\"assets\\\\soundFX\\\\SOUNDEFFECT.wav\", FMOD_2D, 0, &mp_FMODsound_zGroan1);\n    result = mp_FMODsystem->createSound(\"assets\\\\soundFX\\\\SOUNDEFFECT.wav\", FMOD_2D, 0, &mp_FMODsound_zGroan2);\n    result = mp_FMODsystem->createSound(\"assets\\\\soundFX\\\\SOUNDEFFECT.wav\", FMOD_2D, 0, &mp_FMODsound_zAttack);\n    result = mp_FMODsystem->createSound(\"assets\\\\soundFX\\\\SOUNDEFFECT.wav\", FMOD_2D, 0, &mp_FMODsound_zDeath);\n\n    // Music by Eric Matyas    www.soundimage.org\n    result = mp_FMODsystem->createStream(\"assets\\\\soundFX\\\\Monster-Street-Fighters.mp3\", FMOD_2D | FMOD_LOOP_NORMAL, 0, &mp_FMODsound_music);\n\n    if (result != FMOD_OK)\n    {\n        return(false);\n    }\n\n    return(true);\n}\n\nvoid\nAudioManager::Update()\n{\n    mp_FMODsystem->update();\n}\n\n// Two methods to play the player / zombie sound effects\nvoid\nAudioManager::PlaySound(soundEffectsPlayer _SoundEffect)\n{\n    if (!muted)\n    {\n        if (_SoundEffect == se_pSHOOT)\n        {\n            mp_FMODsystem->playSound(mp_FMODsound_pShoot, 0, 0, &mp_FMODchannel);\n        }\n        if (_SoundEffect == se_pRELOAD)\n        {\n            mp_FMODsystem->playSound(mp_FMODsound_pReload, 0, 0, &mp_FMODchannel);\n        }\n        if (_SoundEffect == se_pPICKUP)\n        {\n            mp_FMODsystem->playSound(mp_FMODsound_pPickup, 0, 0, &mp_FMODchannel);\n        }\n        if (_SoundEffect == se_pDEATH)\n        {\n            mp_FMODsystem->playSound(mp_FMODsound_pDeath, 0, 0, &mp_FMODchannel);\n        }\n    }\n    VolumeControl();\n}\nvoid\nAudioManager::PlaySound(soundEffectsZombie _SoundEffect)\n{\n    if (!muted)\n    {\n        if (_SoundEffect == se_zGROAN1)\n        {\n            mp_FMODsystem->playSound(mp_FMODsound_zGroan1, 0, 0, &mp_FMODchannel);\n        }\n        if (_SoundEffect == se_zGROAN2)\n        {\n            mp_FMODsystem->playSound(mp_FMODsound_zGroan2, 0, 0, &mp_FMODchannel);\n        }\n        if (_SoundEffect == se_zATTACK)\n        {\n            mp_FMODsystem->playSound(mp_FMODsound_zAttack, 0, 0, &mp_FMODchannel);\n        }\n        if (_SoundEffect == se_zDEATH)\n        {\n            mp_FMODsystem->playSound(mp_FMODsound_zDeath, 0, 0, &mp_FMODchannel);\n        }\n    }\n    VolumeControl();\n}\n\nvoid\nAudioManager::PlayMusic()\n{\n    mp_FMODsystem->playSound(mp_FMODsound_music, 0, 0, &mp_FMODchannelMusic);\n    mp_FMODchannelMusic->setVolume(volumeMusic);\n\n}\n\nvoid\nAudioManager::VolumeUp()\n{\n    volume += 0.1f;\n    volumeMusic = volume / 3;\n    VolumeControl();\n}\n\nvoid\nAudioManager::VolumeDown()\n{\n    volume -= 0.1f;\n    volumeMusic = volume / 3;\n    VolumeControl();\n}\n\nvoid\nAudioManager::VolumeControl()\n{\n    if (volume <= 0.0f)\n    {\n        muted = true;\n        volume = 0.0f;\n        mp_FMODchannel->setMute(muted);\n        mp_FMODchannel->setVolume(volume);\n        mp_FMODchannelMusic->setMute(muted);\n        mp_FMODchannelMusic->setVolume(volumeMusic);\n    }\n    else\n    {\n        muted = false;\n        if (volume > 1.0f)\n        {\n            volume = 1.0f;\n        }\n        mp_FMODchannel->setMute(muted);\n        mp_FMODchannel->setVolume(volume);\n        mp_FMODchannelMusic->setMute(muted);\n        mp_FMODchannelMusic->setVolume(volumeMusic);\n    }\n}\n\n\n\n\n(FMOD, n.d.)\n\n\nReferences\n\n\n\n\n\n\nBox2D. (n.d.). Retrieved October 22, 2016, from \nhttp://box2d.org/\n\n\n\n\n\n\nFMOD. (n.d.). Retrieved October 22, 2016, from \nhttp://www.fmod.org/",
            "title": "Self Learning"
        },
        {
            "location": "/selflearning/#self-learning",
            "text": "",
            "title": "Self Learning"
        },
        {
            "location": "/selflearning/#general",
            "text": "",
            "title": "General"
        },
        {
            "location": "/selflearning/#level-manager",
            "text": "The Level Manager is a class I put together to help build grid based levels quickly and easily so they can be implemented rapidly for in game testing.\nA text document holds the data to be read in by the game. Working with Excel a document, a level is created by entering single characters into cells that represent different tile types that the Level Manager will create.\nThe Excel documents visual layout assists with giving a representation for the level layout early on.",
            "title": "Level Manager"
        },
        {
            "location": "/selflearning/#level-manager-excel-document",
            "text": "",
            "title": "Level Manager : Excel Document"
        },
        {
            "location": "/selflearning/#level-manager-code",
            "text": "// This includes:\n#include \"LevelManager.h\"\n\n// Local includes:\n#include \"BackBuffer.h\"\n#include \"Sprite.h\"\n#include \"Tile.h\"\n#include <string>\n\n// Library includes:\n\nLevelManager::LevelManager()\n: mi_levelWidth(0)\n, mi_levelHeight(0)\n{\n\n}\n\nLevelManager::~LevelManager()\n{\n    // delete tiles\n    for (unsigned int i = 0; i < tiles.size(); ++i)\n    {\n        //tiles[i]->~Tile();\n        delete tiles[i];\n        tiles[i] = 0;\n    }\n    tiles.clear();\n    //std::vector<Tile*>().swap(tiles);\n}\n\nbool\nLevelManager::Initialise()\n{\n    ReadFile();\n\n    return (true);\n}\n\nvoid\nLevelManager::Process(float deltaTime)\n{\n    for (unsigned int i = 0; i < tiles.size(); ++i)\n    {\n        tiles[i]->Process(deltaTime);\n    }\n}\n\nvoid\nLevelManager::Draw(BackBuffer& backBuffer)\n{\n    for (unsigned int i = 0; i < tiles.size(); ++i)\n    {\n        tiles[i]->Draw(backBuffer);\n    }\n}\n\nvoid\nLevelManager::ReadFile()\n{\n    mapFile.open(\"assets\\\\Level\\\\maplayout.txt\");\n}\n\nvoid\nLevelManager::CreateLevel(BackBuffer* mp_backBuffer, b2World* gameWorld)\n{\n    char tileID;\n\n    // Find Width and Height specified in file. Convert to int.\n    std::string strWidth;\n    std::getline(mapFile, strWidth);\n    std::string strHeight;\n    std::getline(mapFile, strHeight);\n    int mi_levelWidth = atoi(strWidth.c_str());\n    int mi_levelHeight = atoi(strHeight.c_str());\n\n    // Iterate through .txt file and setup tiles.\n    for (int posH = 0; posH < mi_levelHeight; ++posH)\n    {\n        for (int posW = 0; posW < mi_levelWidth; ++posW)\n        {\n            Sprite* pTileSprite;\n\n            mapFile >> (tileID);\n\n            switch (tileID)\n            {\n            case GROUND:\n                //pTileSprite = mp_backBuffer->CreateSprite(\"assets\\\\ground.png\");\n                pTileSprite = mp_backBuffer->CreateSprite(\"assets\\\\Level\\\\ground.png\");\n\n                SetupCollisionTile(pTileSprite, posW, posH, gameWorld, false);\n                break;\n            case WALL:\n                //pTileSprite = mp_backBuffer->CreateSprite(\"assets\\\\wall.png\");\n                pTileSprite = mp_backBuffer->CreateSprite(\"assets\\\\Level\\\\wall.png\");\n\n                SetupCollisionTile(pTileSprite, posW, posH, gameWorld, true);\n                break;\n            case BUILDING:\n                pTileSprite = mp_backBuffer->CreateSprite(\"assets\\\\Level\\\\building.png\");\n\n                SetupCollisionTile(pTileSprite, posW, posH, gameWorld, true);\n                break;\n            default:\n                // Used to catch cases where the tileID does not match. Will draw placeholder asset.\n                pTileSprite = mp_backBuffer->CreateSprite(\"assets\\\\Level\\\\placeholder.png\");\n\n                SetupTile(pTileSprite, posW, posH);\n                break;\n            }\n        }\n    }\n}\n\n// Creates a Tile WITHOUT Box2D properties\nvoid \nLevelManager::SetupTile(Sprite* sprite, int posW, int posH)\n{\n    // Get Sprite width / height\n    int sW = sprite->GetWidth();\n    int sH = sprite->GetWidth();\n\n    Tile* tile = new Tile();\n\n    tile->SetPos(b2Vec2((float)posW * sW, (float)posH * sH));\n    tile->Initialise(sprite); // Height and Width taken as half lengths object width = 2*given width\n\n    tiles.push_back(tile);\n}\n\n// Creates a tile WITH Box2D properties\nvoid\nLevelManager::SetupCollisionTile(Sprite* sprite, int posW, int posH, b2World* gameWorld, bool collision)\n{\n    // Get Sprite width / height\n    int sW = sprite->GetWidth();\n    int sH = sprite->GetWidth();\n\n    Tile* tile = new Tile();\n\n    tile->SetPos(b2Vec2((float)posW * sW, (float)posH * sH));\n    tile->Initialise(sprite, gameWorld, collision); \n\n    tiles.push_back(tile);\n}\n\nvoid\nLevelManager::LevelMoveTiles(float x, float y)\n{\n    for (unsigned int i = 0; i < tiles.size(); ++i)\n    {\n        if (tiles[i]->GetBox2DBody() != 0)\n        {\n            tiles[i]->Move(x, y);\n        }\n        else\n        {\n            //tiles[i]->SetPositionX(x);\n            //tiles[i]->SetPositionY(y);\n        }\n    }\n}\n\nvoid\nLevelManager::LevelStopTiles()\n{\n    for (unsigned int i = 0; i < tiles.size(); ++i)\n    {\n        if (tiles[i]->GetBox2DBody() != 0)\n        {\n            tiles[i]->GetBox2DBody()->SetLinearVelocity(b2Vec2(0, 0));\n        }\n        else\n        {\n\n        }\n    }\n}\n\nstd::vector<Tile*>\nLevelManager::GetTiles()\n{\n    return tiles;\n}",
            "title": "Level Manager : Code"
        },
        {
            "location": "/selflearning/#third-party",
            "text": "",
            "title": "Third Party"
        },
        {
            "location": "/selflearning/#box2d",
            "text": "I picked up Box2D during my game project assignments I took part in while at university.\nBox2D has very well written documentation with numerous other experienced users available online sharing their troubles and solutions.\nThe only issues I faced when using Box2D where the usual growing pains experienced when getting use to something new.\nWhile working with Box2D and SDL. Box2D's positional values had to be adjusted to fit in the scale of the SDL environment.\nThe below example was used to create the Box2D bodies for the level tiles created by the Level Manager.\nOnly walls required full collision information. Whereas the floor tiles only needed a based body to handle positioning.",
            "title": "Box2D"
        },
        {
            "location": "/selflearning/#box2d-code",
            "text": "void\nTile::box2DBodyCreate(b2World* gameWorld, bool collision, float mf_spriteWidth, float mf_spriteHeight)\n{\n    b2BodyDef m_entityBodyDef;\n    m_entityBodyDef.type = b2_kinematicBody;\n    // Origin is at center. Must be offset by sprite width/height\n    // Position settings adjusted based on scale differences between SDL and Box2D\n    m_entityBodyDef.position.Set((mv_pos.x + mf_spriteWidth) * mf_worldScaleB2D, (mv_pos.y + mf_spriteHeight) * mf_worldScaleB2D);\n    m_entityBodyDef.angle = 0;\n    m_entityBodyDef.allowSleep = true;\n    m_entityBodyDef.gravityScale = 0.0f;\n\n    mp_body = gameWorld->CreateBody(&m_entityBodyDef);\n    mp_body->SetUserData(this);\n\n    // Create collision shape if object should collide\n    if (collision)\n    {\n        b2PolygonShape boxShape;\n        // Creates width and height of box (half measures used), given the center, angle\n        boxShape.SetAsBox(mf_spriteWidth * mf_worldScaleB2D, mf_spriteHeight * mf_worldScaleB2D);\n\n        b2FixtureDef boxFixtureDef;\n        boxFixtureDef.shape = &boxShape;\n        boxFixtureDef.friction = 100;\n        boxFixtureDef.filter.categoryBits = 0x0001;\n        boxFixtureDef.filter.maskBits = 0x0001 | 0x0002 | 0x0003 | 0x0004;\n\n        mp_body->CreateFixture(&boxFixtureDef);\n    }\n}  (Box2D, n.d.)",
            "title": "Box2D : Code"
        },
        {
            "location": "/selflearning/#fmod",
            "text": "An Audio Manager class was created to handle my game sounds while working on my university projects.\nOnce again, the documentation for FMOD was very well written and easy to implement. I found it best to setup FMOD within an Audio Manager class.\nThis gave me greater control over the use of sound effects within my games. I also put together little volume controls and channels to allow me to control the volume of my music VS sound effects at different ratios.",
            "title": "FMOD"
        },
        {
            "location": "/selflearning/#audio-manager-code",
            "text": "// Local includes:\n#include \"AudioManager.h\"\n\n// Library includes:\n#include <iostream>\n\nAudioManager::AudioManager()\n: mp_FMODsystem(0)\n, mp_FMODchannel(0)\n, mp_FMODchannelMusic(0)\n, mp_FMODsound_music(nullptr)\n, mp_FMODsound_pShoot(0)\n, mp_FMODsound_pReload(0)\n, mp_FMODsound_pPickup(0)\n, mp_FMODsound_pDeath(0)\n, mp_FMODsound_zGroan1(0)\n, mp_FMODsound_zGroan2(0)\n, mp_FMODsound_zAttack(0)\n, mp_FMODsound_zDeath(0)\n, volume(0.7f)\n, volumeMusic(volume / 3)\n, muted(false)\n{\n}\n\nAudioManager::~AudioManager()\n{\n    mp_FMODsystem->release();\n}\n\nbool\nAudioManager::Initialise()\n{\n    FMOD_RESULT result;\n\n    result = FMOD::System_Create(&mp_FMODsystem);      // Create the main system object.\n    if (result != FMOD_OK)\n    {\n        printf(\"FMOD error! (%d) %s\\n\", result, FMOD_ErrorString(result));\n        exit(-1);\n    }\n\n    result = mp_FMODsystem->init(512, FMOD_INIT_NORMAL, 0);    // Initialize FMOD.\n    if (result != FMOD_OK)\n    {\n        printf(\"FMOD error! (%d) %s\\n\", result, FMOD_ErrorString(result));\n        exit(-1);\n    }\n    // Player Sound Effects\n    result = mp_FMODsystem->createSound(\"assets\\\\soundFX\\\\SOUNDEFFECT.wav\", FMOD_2D, 0, &mp_FMODsound_pShoot);\n    result = mp_FMODsystem->createSound(\"assets\\\\soundFX\\\\SOUNDEFFECT.wav\", FMOD_2D, 0, &mp_FMODsound_pReload);\n    result = mp_FMODsystem->createSound(\"assets\\\\soundFX\\\\SOUNDEFFECT.wav\", FMOD_2D, 0, &mp_FMODsound_pPickup);\n    result = mp_FMODsystem->createSound(\"assets\\\\soundFX\\\\SOUNDEFFECT.wav\", FMOD_2D, 0, &mp_FMODsound_pDeath);\n    // Zombie Sound Effects\n    result = mp_FMODsystem->createSound(\"assets\\\\soundFX\\\\SOUNDEFFECT.wav\", FMOD_2D, 0, &mp_FMODsound_zGroan1);\n    result = mp_FMODsystem->createSound(\"assets\\\\soundFX\\\\SOUNDEFFECT.wav\", FMOD_2D, 0, &mp_FMODsound_zGroan2);\n    result = mp_FMODsystem->createSound(\"assets\\\\soundFX\\\\SOUNDEFFECT.wav\", FMOD_2D, 0, &mp_FMODsound_zAttack);\n    result = mp_FMODsystem->createSound(\"assets\\\\soundFX\\\\SOUNDEFFECT.wav\", FMOD_2D, 0, &mp_FMODsound_zDeath);\n\n    // Music by Eric Matyas    www.soundimage.org\n    result = mp_FMODsystem->createStream(\"assets\\\\soundFX\\\\Monster-Street-Fighters.mp3\", FMOD_2D | FMOD_LOOP_NORMAL, 0, &mp_FMODsound_music);\n\n    if (result != FMOD_OK)\n    {\n        return(false);\n    }\n\n    return(true);\n}\n\nvoid\nAudioManager::Update()\n{\n    mp_FMODsystem->update();\n}\n\n// Two methods to play the player / zombie sound effects\nvoid\nAudioManager::PlaySound(soundEffectsPlayer _SoundEffect)\n{\n    if (!muted)\n    {\n        if (_SoundEffect == se_pSHOOT)\n        {\n            mp_FMODsystem->playSound(mp_FMODsound_pShoot, 0, 0, &mp_FMODchannel);\n        }\n        if (_SoundEffect == se_pRELOAD)\n        {\n            mp_FMODsystem->playSound(mp_FMODsound_pReload, 0, 0, &mp_FMODchannel);\n        }\n        if (_SoundEffect == se_pPICKUP)\n        {\n            mp_FMODsystem->playSound(mp_FMODsound_pPickup, 0, 0, &mp_FMODchannel);\n        }\n        if (_SoundEffect == se_pDEATH)\n        {\n            mp_FMODsystem->playSound(mp_FMODsound_pDeath, 0, 0, &mp_FMODchannel);\n        }\n    }\n    VolumeControl();\n}\nvoid\nAudioManager::PlaySound(soundEffectsZombie _SoundEffect)\n{\n    if (!muted)\n    {\n        if (_SoundEffect == se_zGROAN1)\n        {\n            mp_FMODsystem->playSound(mp_FMODsound_zGroan1, 0, 0, &mp_FMODchannel);\n        }\n        if (_SoundEffect == se_zGROAN2)\n        {\n            mp_FMODsystem->playSound(mp_FMODsound_zGroan2, 0, 0, &mp_FMODchannel);\n        }\n        if (_SoundEffect == se_zATTACK)\n        {\n            mp_FMODsystem->playSound(mp_FMODsound_zAttack, 0, 0, &mp_FMODchannel);\n        }\n        if (_SoundEffect == se_zDEATH)\n        {\n            mp_FMODsystem->playSound(mp_FMODsound_zDeath, 0, 0, &mp_FMODchannel);\n        }\n    }\n    VolumeControl();\n}\n\nvoid\nAudioManager::PlayMusic()\n{\n    mp_FMODsystem->playSound(mp_FMODsound_music, 0, 0, &mp_FMODchannelMusic);\n    mp_FMODchannelMusic->setVolume(volumeMusic);\n\n}\n\nvoid\nAudioManager::VolumeUp()\n{\n    volume += 0.1f;\n    volumeMusic = volume / 3;\n    VolumeControl();\n}\n\nvoid\nAudioManager::VolumeDown()\n{\n    volume -= 0.1f;\n    volumeMusic = volume / 3;\n    VolumeControl();\n}\n\nvoid\nAudioManager::VolumeControl()\n{\n    if (volume <= 0.0f)\n    {\n        muted = true;\n        volume = 0.0f;\n        mp_FMODchannel->setMute(muted);\n        mp_FMODchannel->setVolume(volume);\n        mp_FMODchannelMusic->setMute(muted);\n        mp_FMODchannelMusic->setVolume(volumeMusic);\n    }\n    else\n    {\n        muted = false;\n        if (volume > 1.0f)\n        {\n            volume = 1.0f;\n        }\n        mp_FMODchannel->setMute(muted);\n        mp_FMODchannel->setVolume(volume);\n        mp_FMODchannelMusic->setMute(muted);\n        mp_FMODchannelMusic->setVolume(volumeMusic);\n    }\n}  (FMOD, n.d.)",
            "title": "Audio Manager : Code"
        },
        {
            "location": "/selflearning/#references",
            "text": "Box2D. (n.d.). Retrieved October 22, 2016, from  http://box2d.org/    FMOD. (n.d.). Retrieved October 22, 2016, from  http://www.fmod.org/",
            "title": "References"
        },
        {
            "location": "/pastprojects/",
            "text": "Past Projects\n\n\nDetails\n\n\nDescription\n\n\nI began my journey into the games industry as a 3D artist. These are two of the titles I worked on from conception to launch while I was a part of the development team at Outsmart Games.\n\n\nTools\n\n\nMaya, Unity, Photoshop\n\n\nTasks (Roost Riders)\n\n\nLevel Design, 3D Assets, Texturing, Unity Level Creation\n\n\nTasks (Gopher Launch)\n\n\n3D Assets, Texturing\n\n\nFor\n\n\nOutsmart Games\n\n\nRole\n\n\n3D Artist\n\n\nRoost Riders\n\n\nMy time working on Roost Riders was divided between level design and asset creation.\nThe creation of objects, props, and their textures was shared between one additional artist and myself. Concepts were draw up for all assets by our teams concept artist.\nI had the sole responsibility of designing and creating the level tracks. Tracks were created by building pieces up in Maya that could be arranged in different designs to formulate a range of different track segments.\nTrack segments then had assets place upon them to form obstacles of varying difficulty. Unity gave the freedom to manipulate and place our assets in many different arrangements. This allowed for some very unqiue level design.\n\n\nLaunch Trailer\n\n\n\n\n\n(Outsmart Games, n.d.)\n\n\nScreenshots\n\n\nScreenshots from final game marketing.\n\n\n\n\n\n\n\n\n(Outsmart Games, n.d.)\n\n\nGopher Launch\n\n\nThe most enjoyable tasks I worked on for Gopher launch was providing a solution for the creation of the planets, their textures and their layouts.\nPlanets were made up for three different sections. An inner layer, outter layer, and walls. Both the inner and outter layers shared the same texture and UV space. While the walls only require one tilable texture per quad.\nWorking with the projects primary programmer who was experienced with Maya allowed me to share with him the techniques that he could use to quickly build different level layouts without having to worry about breaking textures/UVs.\n\n\nLaunch Trailer\n\n\n\n\n\n(Outsmart Games, n.d.)\n\n\nScreenshots\n\n\nScreenshots from final game marketing.\n\n\n\n\n\n\n\n\n(Outsmart Games, n.d.)\n\n\nProof of Concept\n\n\nFirst pass grey box levels I created as a proof of concept during the teams preproduction stage.\n\n\n\n\nReferences\n\n\n\n\n\n\nOutsmart Games. (n.d.). Gopher Launch. Retrieved October 22, 2016, from \nhttp://www.outsmartgames.com/gopherlaunch/\n\n\n\n\n\n\nOutsmart Games. (n.d.). Roost Riders. Retrieved October 22, 2016, from \nhttp://www.outsmartgames.com/roostriders/",
            "title": "Past Projects"
        },
        {
            "location": "/pastprojects/#past-projects",
            "text": "",
            "title": "Past Projects"
        },
        {
            "location": "/pastprojects/#details",
            "text": "",
            "title": "Details"
        },
        {
            "location": "/pastprojects/#description",
            "text": "I began my journey into the games industry as a 3D artist. These are two of the titles I worked on from conception to launch while I was a part of the development team at Outsmart Games.",
            "title": "Description"
        },
        {
            "location": "/pastprojects/#tools",
            "text": "Maya, Unity, Photoshop",
            "title": "Tools"
        },
        {
            "location": "/pastprojects/#tasks-roost-riders",
            "text": "Level Design, 3D Assets, Texturing, Unity Level Creation",
            "title": "Tasks (Roost Riders)"
        },
        {
            "location": "/pastprojects/#tasks-gopher-launch",
            "text": "3D Assets, Texturing",
            "title": "Tasks (Gopher Launch)"
        },
        {
            "location": "/pastprojects/#for",
            "text": "Outsmart Games",
            "title": "For"
        },
        {
            "location": "/pastprojects/#role",
            "text": "3D Artist",
            "title": "Role"
        },
        {
            "location": "/pastprojects/#roost-riders",
            "text": "My time working on Roost Riders was divided between level design and asset creation.\nThe creation of objects, props, and their textures was shared between one additional artist and myself. Concepts were draw up for all assets by our teams concept artist.\nI had the sole responsibility of designing and creating the level tracks. Tracks were created by building pieces up in Maya that could be arranged in different designs to formulate a range of different track segments.\nTrack segments then had assets place upon them to form obstacles of varying difficulty. Unity gave the freedom to manipulate and place our assets in many different arrangements. This allowed for some very unqiue level design.",
            "title": "Roost Riders"
        },
        {
            "location": "/pastprojects/#launch-trailer",
            "text": "(Outsmart Games, n.d.)",
            "title": "Launch Trailer"
        },
        {
            "location": "/pastprojects/#screenshots",
            "text": "Screenshots from final game marketing.     (Outsmart Games, n.d.)",
            "title": "Screenshots"
        },
        {
            "location": "/pastprojects/#gopher-launch",
            "text": "The most enjoyable tasks I worked on for Gopher launch was providing a solution for the creation of the planets, their textures and their layouts.\nPlanets were made up for three different sections. An inner layer, outter layer, and walls. Both the inner and outter layers shared the same texture and UV space. While the walls only require one tilable texture per quad.\nWorking with the projects primary programmer who was experienced with Maya allowed me to share with him the techniques that he could use to quickly build different level layouts without having to worry about breaking textures/UVs.",
            "title": "Gopher Launch"
        },
        {
            "location": "/pastprojects/#launch-trailer_1",
            "text": "(Outsmart Games, n.d.)",
            "title": "Launch Trailer"
        },
        {
            "location": "/pastprojects/#screenshots_1",
            "text": "Screenshots from final game marketing.     (Outsmart Games, n.d.)",
            "title": "Screenshots"
        },
        {
            "location": "/pastprojects/#proof-of-concept",
            "text": "First pass grey box levels I created as a proof of concept during the teams preproduction stage.",
            "title": "Proof of Concept"
        },
        {
            "location": "/pastprojects/#references",
            "text": "Outsmart Games. (n.d.). Gopher Launch. Retrieved October 22, 2016, from  http://www.outsmartgames.com/gopherlaunch/    Outsmart Games. (n.d.). Roost Riders. Retrieved October 22, 2016, from  http://www.outsmartgames.com/roostriders/",
            "title": "References"
        },
        {
            "location": "/resume/",
            "text": "Resume\n\n\n\n\nDownload \nAdam Frewen - CV 2016.pdf\n\n\n\n\nContact Details\n\n\n\n\nCellphone: 021 0797 541\n\n\nEmail: adam.frewen@gmail.com",
            "title": "R\u00e9sum\u00e9"
        },
        {
            "location": "/resume/#resume",
            "text": "Download  Adam Frewen - CV 2016.pdf",
            "title": "Resume"
        },
        {
            "location": "/resume/#contact-details",
            "text": "Cellphone: 021 0797 541  Email: adam.frewen@gmail.com",
            "title": "Contact Details"
        }
    ]
}